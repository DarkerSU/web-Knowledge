<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>js时间循环机制（event-loop） | 前端知识集锦</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/web-Knowledge/img/logo.png">
    <link rel="stylesheet" href="/web-Knowledge/css/style.css">
    <meta name="description" content="前端知识集锦">
    
    <link rel="preload" href="/web-Knowledge/assets/css/0.styles.8509ef4e.css" as="style"><link rel="preload" href="/web-Knowledge/assets/js/app.b13197d8.js" as="script"><link rel="preload" href="/web-Knowledge/assets/js/2.c1653dd8.js" as="script"><link rel="preload" href="/web-Knowledge/assets/js/21.10898b7b.js" as="script"><link rel="prefetch" href="/web-Knowledge/assets/js/10.1d44baa9.js"><link rel="prefetch" href="/web-Knowledge/assets/js/11.b68dabc8.js"><link rel="prefetch" href="/web-Knowledge/assets/js/12.2f8912cf.js"><link rel="prefetch" href="/web-Knowledge/assets/js/13.d66a0cf8.js"><link rel="prefetch" href="/web-Knowledge/assets/js/14.7730eee6.js"><link rel="prefetch" href="/web-Knowledge/assets/js/15.4ab39e6d.js"><link rel="prefetch" href="/web-Knowledge/assets/js/16.384eef12.js"><link rel="prefetch" href="/web-Knowledge/assets/js/17.dfb659bf.js"><link rel="prefetch" href="/web-Knowledge/assets/js/18.7922d437.js"><link rel="prefetch" href="/web-Knowledge/assets/js/19.c49f5100.js"><link rel="prefetch" href="/web-Knowledge/assets/js/20.e267671f.js"><link rel="prefetch" href="/web-Knowledge/assets/js/3.5b75cc7e.js"><link rel="prefetch" href="/web-Knowledge/assets/js/4.91c2f1a1.js"><link rel="prefetch" href="/web-Knowledge/assets/js/5.51d3cdee.js"><link rel="prefetch" href="/web-Knowledge/assets/js/6.65e651bc.js"><link rel="prefetch" href="/web-Knowledge/assets/js/7.8a115e09.js"><link rel="prefetch" href="/web-Knowledge/assets/js/8.38a6d515.js"><link rel="prefetch" href="/web-Knowledge/assets/js/9.a8e1e5c8.js">
    <link rel="stylesheet" href="/web-Knowledge/assets/css/0.styles.8509ef4e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/web-Knowledge/" class="home-link router-link-active"><!----> <span class="site-name">前端知识集锦</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web-Knowledge/interview/" class="nav-link router-link-active">
  面试集锦
</a></div><div class="nav-item"><a href="https://github.com/DarkerSU/web-interview" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web-Knowledge/interview/" class="nav-link router-link-active">
  面试集锦
</a></div><div class="nav-item"><a href="https://github.com/DarkerSU/web-interview" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>浏览器、HTTP</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web-Knowledge/interview/notes/浏览器及http.html" class="active sidebar-link">浏览器、HTTP基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#js时间循环机制-event-loop" class="sidebar-link">js时间循环机制（event-loop）</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#浏览器渲染流程" class="sidebar-link">浏览器渲染流程</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#http的请求方式及用途" class="sidebar-link">HTTP的请求方式及用途</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#前端性能优化" class="sidebar-link">前端性能优化</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#跨域" class="sidebar-link">跨域</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#cookie和session" class="sidebar-link">cookie和session</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#cookies-sessionstorage和localstorage区别" class="sidebar-link">cookies sessionStorage和localstorage区别</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#http-和-https-比较" class="sidebar-link">http 和 https 比较</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#浏览器缓存机制" class="sidebar-link">浏览器缓存机制</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#输入url到显示页面发生过程" class="sidebar-link">输入url到显示页面发生过程</a></li><li class="sidebar-sub-header"><a href="/web-Knowledge/interview/notes/浏览器及http.html#xss和csrf" class="sidebar-link">XSS和CSRF</a></li></ul></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTML、CSS</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>DOM</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>javascript</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>React</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>小程序</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack</span> <span class="arrow right"></span></p> <!----></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="js时间循环机制-event-loop"><a href="#js时间循环机制-event-loop" class="header-anchor">#</a> js时间循环机制（event-loop）</h2> <p>时间循环机制由三部分组成</p> <p><strong>调用栈</strong> <strong>微任务队列</strong> <strong>消息队列</strong></p> <div class="custom-block tip"><p class="custom-block-title">注：</p> <p>event-loop开始时，会从全局一行一行的执行，遇到函数调用，会压入到调用栈中，被压入的函数被称为帧，当函数返回后回从调用栈中弹出</p> <p>js中异步操作，比如fetch、setTimeout、setInterval压入调用栈中的时候里面的消息会进入到消息队列中，消息队列中的会等到调用栈清空之后再执行</p> <p>promise、async、await的异步操作的时候会加入到微任务队列中去，会在调用栈清空的时候立即执行，调用栈中加入的微任务会立马执行</p></div> <h2 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="header-anchor">#</a> 浏览器渲染流程</h2> <div class="custom-block tip"><p class="custom-block-title">流程：</p> <p>DNS解析：把域名解析成IP地址</p> <p>TCP 建立连接：TCP三次握手</p> <p>发送HTTP请求</p> <p>服务器处理并响应报文</p> <p>浏览器解析并渲染页面</p> <p>断开连接：TCP 结束连接</p></div> <h2 id="http的请求方式及用途"><a href="#http的请求方式及用途" class="header-anchor">#</a> HTTP的请求方式及用途</h2> <p><strong>GET方法</strong></p> <p>发送一个请求来取得服务器上的某一资源</p> <p><strong>POST方法</strong></p> <p>向URL指定的资源提交数据或附加新的数据</p> <p><strong>PUT方法</strong></p> <p>跟POST方法很像，也是想服务器提交数据。但是，它们之间有不同。PUT指定了资源在服务器上的位置，而POST没有</p> <p><strong>HEAD方法</strong></p> <p>只请求页面的首部</p> <p><strong>DELETE方法</strong></p> <p>删除服务器上的某资源</p> <p><strong>OPTIONS方法</strong></p> <p>它用于获取当前URL所支持的方法。如果请求成功，会有一个Allow的头包含类似“GET,POST”这样的信息</p> <p><strong>TRACE方法</strong></p> <p>TRACE方法被用于激发一个远程的，应用层的请求消息回路</p> <p><strong>CONNECT方法</strong></p> <p>把请求连接转换到透明的TCP/IP通道</p> <h2 id="前端性能优化"><a href="#前端性能优化" class="header-anchor">#</a> 前端性能优化</h2> <div class="custom-block tip"><p class="custom-block-title">优化方案</p> <p>1.压缩 css, js, 图片</p> <p>2.减少 http 请求次数， 合并 css、js 、合并图片（雪碧图）</p> <p>3.使用 CDN</p> <p>4.减少 dom 元素数量</p> <p>5.图片懒加载</p> <p>6.静态资源另外用无 cookie 的域名</p> <p>7.减少 dom 的访问（缓存 dom）</p> <p>8.巧用事件委托</p> <p>9.样式表置顶、脚本置低</p></div> <h2 id="跨域"><a href="#跨域" class="header-anchor">#</a> 跨域</h2> <h3 id="_1、webpack-proxy-前端方式"><a href="#_1、webpack-proxy-前端方式" class="header-anchor">#</a> 1、webpack proxy（前端方式）</h3> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>devServer<span class="token operator">:</span><span class="token punctuation">{</span>
    proxy<span class="token operator">:</span><span class="token punctuation">{</span> <span class="token comment">//代理</span>
        <span class="token string">'/api'</span><span class="token operator">:</span><span class="token punctuation">{</span>
            target<span class="token operator">:</span><span class="token string">'http://localhost:3000/'</span><span class="token punctuation">,</span>
            pathRewrite<span class="token operator">:</span><span class="token punctuation">{</span><span class="token string">'/api'</span><span class="token operator">:</span><span class="token string">''</span><span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="_2、cors-后端方式"><a href="#_2、cors-后端方式" class="header-anchor">#</a> 2、cors（后端方式）</h3> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">allowCorssDomain</span><span class="token operator">=</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">req<span class="token punctuation">,</span>res<span class="token punctuation">,</span>next</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 请求源</span>
    res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Origin'</span><span class="token punctuation">,</span><span class="token string">'*'</span><span class="token punctuation">)</span>
    <span class="token comment">// 请求头</span>
    res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Headers'</span><span class="token punctuation">,</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span>
    <span class="token comment">// 请求方法 get/post/delete/put</span>
    res<span class="token punctuation">.</span><span class="token function">header</span><span class="token punctuation">(</span><span class="token string">'Access-Control-Allow-Methods'</span><span class="token punctuation">,</span><span class="token string">&quot;*&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>allowCorssDomain<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_3、中间件-nginx"><a href="#_3、中间件-nginx" class="header-anchor">#</a> 3、中间件（nginx）</h3> <h3 id="_4、webpack-plugin-前端方式"><a href="#_4、webpack-plugin-前端方式" class="header-anchor">#</a> 4、webpack plugin （前端方式 ）</h3> <p>webpack-dev-middleware设置在服务端。是客户端和服务端在用一个文件下</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">const</span> webpack <span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> middleware<span class="token operator">=</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'webpack-dev-middleware'</span><span class="token punctuation">)</span>
<span class="token keyword">const</span> compiler <span class="token operator">=</span><span class="token function">webpack</span><span class="token punctuation">(</span><span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./webpack.config.js'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
app<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token function">middleware</span><span class="token punctuation">(</span>compiler<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="_5、vue-proxy"><a href="#_5、vue-proxy" class="header-anchor">#</a> 5、Vue proxy</h3> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code>devServer<span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token comment">// 配置后台数据请求代理 </span>
    proxy<span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string">'/api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            target<span class="token operator">:</span> <span class="token string">'http://127.0.0.1:5055'</span><span class="token punctuation">,</span><span class="token comment">//代理的目标服务器</span>
            changeOrigin<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            ws<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            pathRewrite<span class="token operator">:</span> <span class="token punctuation">{</span> <span class="token comment">//路径重写</span>
                <span class="token string">'^/api'</span><span class="token operator">:</span> <span class="token string">'/api'</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span><span class="token punctuation">,</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><h2 id="cookie和session"><a href="#cookie和session" class="header-anchor">#</a> cookie和session</h2> <p>cookie和session都是用来跟踪浏览器用户身份的会话方式。</p> <p>区别：</p> <ol><li>保持状态：cookie保存在浏览器端，session保存在服务器端</li> <li>使用方式：</li></ol> <p>（1）cookie机制：如果不在浏览器中设置过期时间，cookie被保存在内存中，生命周期随浏览器的关闭而结束，这种cookie简称会话cookie。如果在浏览器中设置了cookie的过期时间，cookie被保存在硬盘中，关闭浏览器后，cookie数据仍然存在，直到过期时间结束才消失。</p> <p>Cookie是服务器发给客户端的特殊信息，cookie是以文本的方式保存在客户端，每次请求时都带上它</p> <p>（2）session机制：当服务器收到请求需要创建session对象时，首先会检查客户端请求中是否包含sessionid。如果有sessionid，服务器将根据该id返回对应session对象。如果客户端请求中没有sessionid，服务器会创建新的session对象，并把sessionid在本次响应中返回给客户端。通常使用cookie方式存储sessionid到客户端，在交互中浏览器按照规则将sessionid发送给服务器。如果用户禁用cookie，则要使用URL重写，可以通过response.encodeURL(url) 进行实现；API对encodeURL的结束为，当浏览器支持Cookie时，url不做任何处理；当浏览器不支持Cookie的时候，将会重写URL将SessionID拼接到访问地址后。</p> <ol start="3"><li>存储内容：cookie只能保存字符串类型，以文本的方式；session通过类似与Hashtable的数据结构来保存，能支持任何类型的对象(session中可含有多个对象)</li> <li>存储的大小：cookie：单个cookie保存的数据不能超过4kb；session大小没有限制。</li> <li>安全性：cookie：针对cookie所存在的攻击：Cookie欺骗，Cookie截获；session的安全性大于cookie。</li></ol> <p>原因如下：（1）sessionID存储在cookie中，若要攻破session首先要攻破cookie；</p> <p>（2）sessionID是要有人登录，或者启动session_start才会有，所以攻破cookie也不一定能得到sessionID；</p> <p>（3）第二次启动session_start后，前一次的sessionID就是失效了，session过期后，sessionID也随之失效。</p> <p>（4）sessionID是加密的</p> <p>（5）综上所述，攻击者必须在短时间内攻破加密的sessionID，这很难。</p> <ol start="6"><li>应用场景：</li></ol> <p>cookie：（1）判断用户是否登陆过网站，以便下次登录时能够实现自动登录（或者记住密码）。如果我们删除cookie，则每次登录必须从新填写登录的相关信息。</p> <p>（2）保存上次登录的时间等信息。</p> <p>（3）保存上次查看的页面</p> <p>（4）浏览计数</p> <p><img src="https://images2018.cnblogs.com/blog/1287779/201804/1287779-20180404062350828-745185789.png" alt="img"></p> <p>session：Session用于保存每个用户的专用信息，变量的值保存在服务器端，通过SessionID来区分不同的客户。</p> <p>（1）网上商城中的购物车</p> <p>（2）保存用户登录信息</p> <p>（3）将某些数据放入session中，供同一用户的不同页面使用</p> <p>（4）防止用户非法登录</p> <ol start="7"><li>缺点：cookie：（1）大小受限</li></ol> <p>（2）用户可以操作（禁用）cookie，使功能受限</p> <p>（3）安全性较低</p> <p>（4）有些状态不可能保存在客户端。</p> <p>（5）每次访问都要传送cookie给服务器，浪费带宽。</p> <p>（6）cookie数据有路径（path）的概念，可以限制cookie只属于某个路径下。</p> <p>session：（1）Session保存的东西越多，就越占用服务器内存，对于用户在线人数较多的网站，服务器的内存压力会比较大。</p> <p>（2）依赖于cookie（sessionID保存在cookie），如果禁用cookie，则要使用URL重写，不安全</p> <p>（3）创建Session变量有很大的随意性，可随时调用，不需要开发者做精确地处理，所以，过度使用session变量将会导致代码不可读而且不好维护。</p> <h2 id="cookies-sessionstorage和localstorage区别"><a href="#cookies-sessionstorage和localstorage区别" class="header-anchor">#</a> cookies sessionStorage和localstorage区别</h2> <ul><li>cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）</li> <li>cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递</li> <li>**<code>sessionStorage</code><strong>和</strong><code>localStorage</code>**不会自动把数据发给服务器，仅在本地保存</li> <li><strong>存储大小：</strong> <ul><li>cookie数据大小不能超过4k</li> <li>**<code>sessionStorage</code><strong>和</strong><code>localStorage</code>**虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大</li></ul></li> <li><strong>有期时间：</strong> <ul><li><strong><code>localStorage</code></strong> 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据</li> <li><strong><code>sessionStorage</code></strong> 数据在当前浏览器窗口关闭后自动删除</li> <li>cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭</li></ul></li></ul> <h2 id="http-和-https-比较"><a href="#http-和-https-比较" class="header-anchor">#</a> http 和 https 比较</h2> <p>http是HTTP协议运行在TCP之上。所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。</p> <p>https是HTTP运行在SSL/TLS之上，SSL/TLS运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。此外客户端可以验证服务器端的身份，如果配置了客户端验证，服务器方也可以验证客户端的身份</p> <h2 id="浏览器缓存机制"><a href="#浏览器缓存机制" class="header-anchor">#</a> 浏览器缓存机制</h2> <p>浏览器缓存分为强缓存和协商缓存</p> <ul><li><strong>强缓存</strong>：利用http的返回头中的Expires或者Cache-Control两个字段来控制的，用来表示资源的缓存时间</li> <li><strong>协商缓存</strong>：客户端向服务器端发出请求，服务端会检测是否有对应的标识，如果没有对应的标识，服务器端会返回一个对应的标识给客户端，客户端下次再次请求的时候，把该标识带过去，然后服务器端会验证该标识，如果验证通过了，则会响应304，告诉浏览器读取缓存。如果标识没有通过，则返回请求的资源。</li></ul> <p><strong>Cache-Control</strong></p> <div class="custom-block tip"><p class="custom-block-title">cache-control取值</p> <p>Cache-Control 可以由多个字段组合而成，主要有以下几个取值：</p> <p><strong>max-age</strong>：定一个时间长度，在这个时间段内缓存是有效的，单位是s。</p> <p><strong>public</strong> ：表明响应可以被任何对象（发送请求的客户端、代理服务器等等）缓存。</p> <p><strong>private</strong> ：表明响应只能被单个用户（可能是操作系统用户、浏览器用户）缓存，是非共享的，不能被代理服务器缓存。</p> <p><strong>no-cache</strong> ：强制所有缓存了该响应的用户，在使用已缓存的数据前，发送带验证器的请求到服务器。不是字面意思上的不缓存。</p> <p><strong>no-store</strong> ：禁止缓存，每次请求都要向服务器重新获取数据。</p></div> <h2 id="输入url到显示页面发生过程"><a href="#输入url到显示页面发生过程" class="header-anchor">#</a> 输入url到显示页面发生过程</h2> <p>一般会经历以下几个过程：</p> <div class="custom-block warning"><p class="custom-block-title">详细流程</p> <ol><li>首先，在浏览器地址栏中输入url</li> <li><strong>查缓存</strong>：浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。</li> <li><strong>域名解析</strong>：在发送http请求前，需要域名解析(DNS解析)(DNS（域名系统，Domain Name System）是互联网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住IP地址。)，解析获取相应的IP地址。</li> <li><strong>建立连接</strong>：浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。（TCP即传输控制协议。TCP连接是互联网连接协议集的一种。）</li> <li>握手成功后，浏览器向服务器发送http请求，请求数据包。</li> <li><strong>发送数据</strong>：服务器处理收到的请求，将数据返回至浏览器</li> <li>浏览器收到HTTP响应</li> <li><strong>渲染页面</strong>：读取页面内容，浏览器渲染，解析html源码</li> <li>生成Dom树、解析css样式、js交互</li></ol> <p>10、客户端和服务器交互</p> <p>11、ajax查询</p></div> <h2 id="xss和csrf"><a href="#xss和csrf" class="header-anchor">#</a> XSS和CSRF</h2> <p><strong>XSS</strong>（Cross Site Scripting）：跨域脚本攻击。</p> <div class="custom-block tip"><p class="custom-block-title">攻击原理及防御</p> <p>XSS攻击的核心原理是：不需要你做任何的登录认证，它会通过合法的操作（比如在url中输入、在评论框中输入），向你的页面注入脚本（可能是js、hmtl代码块等）</p> <p>XSS：将一些隐私数据像cookie，session发给攻击者，将受害者重定向到一个有攻击者控制的网站</p></div> <p><strong>CSRF</strong>（Cross-site request forgery）：跨站请求伪造。</p> <p>CSRF如何防御：</p> <div class="custom-block tip"><p class="custom-block-title">防御方法</p> <p><strong>方法一</strong>、Token 验证：（用的最多）</p> <p>（1）服务器发送给客户端一个token；</p> <p>（2）客户端提交的表单中带着这个token。</p> <p>（3）如果这个 token 不合法，那么服务器拒绝这个请求。</p> <p><strong>方法二</strong>：隐藏令牌：</p> <p>把 token 隐藏在 http 的 head头中。</p> <p>方法二和方法一有点像，本质上没有太大区别，只是使用方式上有区别。</p> <p><strong>方法三</strong>、Referer 验证：</p> <p>Referer 指的是页面请求来源。意思是，只接受本站的请求，服务器才做响应；如果不是，就拦截。</p></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">7/14/2021, 10:28:53 AM</span></div></footer> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/web-Knowledge/interview/notes/HTML.html">
        HTML
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/web-Knowledge/assets/js/app.b13197d8.js" defer></script><script src="/web-Knowledge/assets/js/2.c1653dd8.js" defer></script><script src="/web-Knowledge/assets/js/21.10898b7b.js" defer></script>
  </body>
</html>

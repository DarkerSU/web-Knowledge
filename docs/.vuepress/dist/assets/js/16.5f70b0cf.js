(window.webpackJsonp=window.webpackJsonp||[]).push([[16],{372:function(t,s,a){"use strict";a.r(s);var e=a(42),v=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"react-生命周期函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-生命周期函数"}},[t._v("#")]),t._v(" react 生命周期函数")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("**运行中**：")]),t._v(" "),a("p",[a("strong",[t._v("getDefaultProps")]),t._v("：获取实例的默认属性")]),t._v(" "),a("p",[a("strong",[t._v("getInitialState")]),t._v("：获取每个实例的初始化状态")]),t._v(" "),a("p",[a("strong",[t._v("componentWillMount")]),t._v("：组件即将被装载、渲染到页面上")]),t._v(" "),a("p",[a("strong",[t._v("render")]),t._v("：组件在这里生成虚拟的 DOM 节点")]),t._v(" "),a("p",[a("strong",[t._v("componentDidMount")]),t._v("：组件真正在被装载之后")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("**运行中状态**：")]),t._v(" "),a("p",[a("strong",[t._v("componentWillReceiveProps")]),t._v("：组件将要接收到属性的时候调用")]),t._v(" "),a("p",[a("strong",[t._v("shouldComponentUpdate")]),t._v("：组件接受到新属性或者新状态的时候（可以返回 false，接收数据后不更新，阻止render 调用，后面的函数不会被继续执行了）")]),t._v(" "),a("p",[a("strong",[t._v("componentWillUpdate")]),t._v("：组件即将更新不能修改属性和状态")]),t._v(" "),a("p",[a("strong",[t._v("render")]),t._v("：组件重新描绘")]),t._v(" "),a("p",[a("strong",[t._v("componentDidUpdate")]),t._v("：组件已经更新")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("**销毁阶段**：")]),t._v(" "),a("p",[a("strong",[t._v("componentWillUnmount")]),t._v(":组件即将销毁")])]),t._v(" "),a("h2",{attrs:{id:"state-和-props-区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#state-和-props-区别"}},[t._v("#")]),t._v(" state 和 props 区别")]),t._v(" "),a("p",[t._v("​\t\tprops和state是普通的 JS 对象。虽然它们都包含影响渲染输出的信息，但是它们在组件方面的功能是不同的。即")]),t._v(" "),a("ul",[a("li",[t._v("state 是组件自己管理数据，控制自己的状态，可变；")]),t._v(" "),a("li",[t._v("props 是外部传入的数据参数，不可变；")]),t._v(" "),a("li",[t._v("没有state的叫做无状态组件，有state的叫做有状态组件；")]),t._v(" "),a("li",[t._v("多用 props，少用 state，也就是多写无状态组件。")])]),t._v(" "),a("h6",{attrs:{id:"问题1-为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#问题1-为什么建议传递给-setstate-的参数是一个-callback-而不是一个对象"}},[t._v("#")]),t._v(" 问题1：为什么建议传递给 setState 的参数是一个 callback 而不是一个对象？")]),t._v(" "),a("p",[t._v("因为this.props 和this.state 的更新可能是异步的，不能依赖它们的值去计算下一个 state")]),t._v(" "),a("h2",{attrs:{id:"react-diff-原理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-diff-原理"}},[t._v("#")]),t._v(" React diff 原理")]),t._v(" "),a("ul",[a("li",[t._v("把树形结构按照层级分解，只比较同级元素")]),t._v(" "),a("li",[t._v("给列表结构的每个单元添加唯一的 key 属性，方便比较")]),t._v(" "),a("li",[t._v("React 只会匹配相同 class 的 component（这里面的 class 指的是组件的名字）")]),t._v(" "),a("li",[t._v("选择性子树渲染。开发人员可以重写shouldComponentUpdate 提高 diff 的性能")])]),t._v(" "),a("h2",{attrs:{id:"react-中-refs-的作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-中-refs-的作用"}},[t._v("#")]),t._v(" React 中 refs 的作用")]),t._v(" "),a("p",[t._v("​\t\tRefs 是 React 提供给我们的安全访问 DOM 元素或者某个组件实例的句柄。")]),t._v(" "),a("p",[t._v("我们可以为元素添加 ref 属性然后在回调函数中接受该元素在 DOM 树中的句柄，该值会作为回调函数的第一个参数返回")]),t._v(" "),a("h2",{attrs:{id:"react-中有三种构建组件的方式"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#react-中有三种构建组件的方式"}},[t._v("#")]),t._v(" React 中有三种构建组件的方式")]),t._v(" "),a("p",[t._v("React.createClass()、ES6 class 和无状态函数。")]),t._v(" "),a("h2",{attrs:{id:"类式组件和函数比较"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类式组件和函数比较"}},[t._v("#")]),t._v(" 类式组件和函数比较")]),t._v(" "),a("p",[t._v("类组件可以使用其他特性，如状态 "),a("code",[t._v("state")]),t._v(" 和生命周期钩子；")]),t._v(" "),a("p",[t._v("函数组件的性能比类组件的性能要高，因为类组件使用的时候要实例化，而函数组件直接执行函数取返回结果即可。为了提高性能，尽量使用函数组件。")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",[t._v("区别")]),t._v(" "),a("th",[t._v("函数组件")]),t._v(" "),a("th",[t._v("类组件")])])]),t._v(" "),a("tbody",[a("tr",[a("td",[t._v("是否有 this")]),t._v(" "),a("td",[t._v("没有")]),t._v(" "),a("td",[t._v("有")])]),t._v(" "),a("tr",[a("td",[t._v("是否有生命周期")]),t._v(" "),a("td",[t._v("没有")]),t._v(" "),a("td",[t._v("有")])]),t._v(" "),a("tr",[a("td",[t._v("是否有状态 state")]),t._v(" "),a("td",[t._v("没有")]),t._v(" "),a("td",[t._v("有")])])])]),t._v(" "),a("h2",{attrs:{id:"什么是高阶组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是高阶组件"}},[t._v("#")]),t._v(" 什么是高阶组件？")]),t._v(" "),a("p",[t._v("​\t\t高阶组件(HOC)是接受一个组件并返回一个新组件的函数。基本上，这是一个模式，是从 React 的组合特性中衍生出来的，称其为纯组件，因为它们可以接受任何动态提供的子组件，但不会修改或复制输入组件中的任何行为。")]),t._v(" "),a("p",[a("code",[t._v("const EnhancedComponent = higherOrderComponent(WrappedComponent);")])]),t._v(" "),a("p",[t._v("HOC 可以用于以下许多用例")]),t._v(" "),a("ul",[a("li",[t._v("代码重用、逻辑和引导抽象")]),t._v(" "),a("li",[t._v("渲染劫持")]),t._v(" "),a("li",[t._v("state 抽象和操作")]),t._v(" "),a("li",[t._v("props 处理")])]),t._v(" "),a("h2",{attrs:{id:"redux"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux"}},[t._v("#")]),t._v(" Redux")]),t._v(" "),a("p",[t._v("Redux 使用 “Store” 将程序的整个状态存储在同一个地方。因此所有组件的状态都存储在 Store 中，并且它们从 Store 本身接收更新。单一状态树可以更容易地跟踪随时间的变化，并调试或检查程序。")]),t._v(" "),a("h4",{attrs:{id:"redux遵循的三个原则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux遵循的三个原则"}},[t._v("#")]),t._v(" Redux遵循的三个原则")]),t._v(" "),a("ul",[a("li",[a("strong",[t._v("单一事实来源")]),t._v("：整个应用的状态存储在单个 store 中的对象/状态树里。单一状态树可以更容易地跟踪随时间的变化，并调试或检查应用程序。")]),t._v(" "),a("li",[a("strong",[t._v("状态是只读的")]),t._v("：改变状态的唯一方法是去触发一个动作。动作是描述变化的普通 JS 对象。就像 state 是数据的最小表示一样，该操作是对数据更改的最小表示。")]),t._v(" "),a("li",[a("strong",[t._v("使用纯函数进行更改")]),t._v("：为了指定状态树如何通过操作进行转换，你需要纯函数。纯函数是那些返回值仅取决于其参数值的函数。")])]),t._v(" "),a("h4",{attrs:{id:"redux-组件"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-组件"}},[t._v("#")]),t._v(" Redux 组件")]),t._v(" "),a("ul",[a("li",[t._v("Action – 这是一个用来描述发生了什么事情的对象。")]),t._v(" "),a("li",[t._v("Reducer – 这是一个确定状态将如何变化的地方。")]),t._v(" "),a("li",[t._v("Store – 整个程序的状态/对象树保存在Store中。")]),t._v(" "),a("li",[t._v("View – 只显示 Store 提供的数据。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("**如何在 Redux 中定义 Action？**")]),t._v(" "),a("p",[t._v("​\tReact 中的 Action 必须具有 type 属性，该属性指示正在执行的 ACTION 的类型。必须将它们定义为字符串常量，并且还可以向其添加更多的属性。在 Redux 中，action 被名为 Action Creators 的函数所创建。")]),t._v(" "),a("div",{staticClass:"language-js line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-js"}},[a("code",[a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("function")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[t._v("addTodo")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token parameter"}},[t._v("text")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n       "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n                type"),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token constant"}},[t._v("ADD_TODO")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v("   \n                 text\n    "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br"),a("span",{staticClass:"line-number"},[t._v("2")]),a("br"),a("span",{staticClass:"line-number"},[t._v("3")]),a("br"),a("span",{staticClass:"line-number"},[t._v("4")]),a("br"),a("span",{staticClass:"line-number"},[t._v("5")]),a("br"),a("span",{staticClass:"line-number"},[t._v("6")]),a("br")])])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("**解释 Reducer 的作用**")]),t._v(" "),a("p",[t._v("​\t\tReducers 是纯函数，它规定应用程序的状态怎样因响应 ACTION 而改变。Reducers 通过接受先前的状态和 action 来工作，然后它返回一个新的状态。它根据操作的类型确定需要执行哪种更新，然后返回新的值。如果不需要完成任务，它会返回原来的状态。")])]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("**Store 在 Redux 中的意义是什么？**")]),t._v(" "),a("p",[t._v("​\t\tStore 是一个 JavaScript 对象，它可以保存程序的状态，并提供一些方法来访问状态、调度操作和注册侦听器。应用程序的整个状态/对象树保存在单一存储中。因此，Redux 非常简单且是可预测的。我们可以将中间件传递到 store 来处理数据，并记录改变存储状态的各种操作。所有操作都通过 reducer 返回一个新状态。")])]),t._v(" "),a("h4",{attrs:{id:"redux-优点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#redux-优点"}},[t._v("#")]),t._v(" Redux 优点？")]),t._v(" "),a("ul",[a("li",[t._v("结果的可预测性 - 由于总是存在一个真实来源，即 store ，因此不存在如何将当前状态与动作和应用的其他部分同步的问题。")]),t._v(" "),a("li",[t._v("可维护性 - 代码变得更容易维护，具有可预测的结果和严格的结构。")]),t._v(" "),a("li",[t._v("服务器端渲染 - 你只需将服务器上创建的 store 传到客户端即可。这对初始渲染非常有用，并且可以优化应用性能，从而提供更好的用户体验。")]),t._v(" "),a("li",[t._v("开发人员工具 - 从操作到状态更改，开发人员可以实时跟踪应用中发生的所有事情。")]),t._v(" "),a("li",[t._v("社区和生态系统 - Redux 背后有一个巨大的社区，这使得它更加迷人。一个由才华横溢的人组成的大型社区为库的改进做出了贡献，并开发了各种应用。")]),t._v(" "),a("li",[t._v("易于测试 - Redux 的代码主要是小巧、纯粹和独立的功能。这使代码可测试且独立。")]),t._v(" "),a("li",[t._v("组织 - Redux 准确地说明了代码的组织方式，这使得代码在团队使用时更加一致和简单。")])])])}),[],!1,null,null,null);s.default=v.exports}}]);
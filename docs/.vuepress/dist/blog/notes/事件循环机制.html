<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>你不知道的事件循环机制？ | 前端知识集锦</title>
    <meta name="generator" content="VuePress 1.7.1">
    <link rel="icon" href="/web-Knowledge/img/logo.png">
    <link rel="stylesheet" href="/web-Knowledge/css/style.css">
    <meta name="description" content="前端知识集锦">
    
    <link rel="preload" href="/web-Knowledge/assets/css/0.styles.8509ef4e.css" as="style"><link rel="preload" href="/web-Knowledge/assets/js/app.fe16e1aa.js" as="script"><link rel="preload" href="/web-Knowledge/assets/js/2.c1653dd8.js" as="script"><link rel="preload" href="/web-Knowledge/assets/js/12.e4dc71a4.js" as="script"><link rel="prefetch" href="/web-Knowledge/assets/js/10.0c5c0072.js"><link rel="prefetch" href="/web-Knowledge/assets/js/11.6fc8a8a7.js"><link rel="prefetch" href="/web-Knowledge/assets/js/13.8cf8f891.js"><link rel="prefetch" href="/web-Knowledge/assets/js/14.9fb7d108.js"><link rel="prefetch" href="/web-Knowledge/assets/js/15.857e719d.js"><link rel="prefetch" href="/web-Knowledge/assets/js/16.8cb2d829.js"><link rel="prefetch" href="/web-Knowledge/assets/js/17.8e2bac74.js"><link rel="prefetch" href="/web-Knowledge/assets/js/18.be1f9e54.js"><link rel="prefetch" href="/web-Knowledge/assets/js/19.f25e7bbe.js"><link rel="prefetch" href="/web-Knowledge/assets/js/20.4f28efb3.js"><link rel="prefetch" href="/web-Knowledge/assets/js/21.fad52b07.js"><link rel="prefetch" href="/web-Knowledge/assets/js/22.3e7b29e9.js"><link rel="prefetch" href="/web-Knowledge/assets/js/23.f20cf17d.js"><link rel="prefetch" href="/web-Knowledge/assets/js/24.26c81197.js"><link rel="prefetch" href="/web-Knowledge/assets/js/25.5c37c265.js"><link rel="prefetch" href="/web-Knowledge/assets/js/26.2c9e4c8f.js"><link rel="prefetch" href="/web-Knowledge/assets/js/27.a4300eed.js"><link rel="prefetch" href="/web-Knowledge/assets/js/3.46c2d41a.js"><link rel="prefetch" href="/web-Knowledge/assets/js/4.91c2f1a1.js"><link rel="prefetch" href="/web-Knowledge/assets/js/5.51d3cdee.js"><link rel="prefetch" href="/web-Knowledge/assets/js/6.65e651bc.js"><link rel="prefetch" href="/web-Knowledge/assets/js/7.8a115e09.js"><link rel="prefetch" href="/web-Knowledge/assets/js/8.494552e1.js"><link rel="prefetch" href="/web-Knowledge/assets/js/9.be9ddd37.js">
    <link rel="stylesheet" href="/web-Knowledge/assets/css/0.styles.8509ef4e.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/web-Knowledge/" class="home-link router-link-active"><!----> <span class="site-name">前端知识集锦</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/web-Knowledge/blog/" class="nav-link router-link-active">
  开发应用
</a></div><div class="nav-item"><a href="/web-Knowledge/interview/" class="nav-link">
  面试集锦
</a></div><div class="nav-item"><a href="https://github.com/DarkerSU/web-interview" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/web-Knowledge/blog/" class="nav-link router-link-active">
  开发应用
</a></div><div class="nav-item"><a href="/web-Knowledge/interview/" class="nav-link">
  面试集锦
</a></div><div class="nav-item"><a href="https://github.com/DarkerSU/web-interview" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS开发技巧</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web-Knowledge/blog/notes/JS开发技巧.html" class="sidebar-link">JS开发技巧应用</a></li></ul></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Vue</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>webpack配置相关</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>事件循环机制，你真的了解吗？</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/web-Knowledge/blog/notes/事件循环机制.html" class="active sidebar-link">事件循环机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/web-Knowledge/blog/notes/事件循环机制.html#你不知道的事件循环机制" class="sidebar-link">你不知道的事件循环机制？</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="你不知道的事件循环机制"><a href="#你不知道的事件循环机制" class="header-anchor">#</a> 你不知道的事件循环机制？</h2> <p>JS事件循环机制分为浏览器循环机制和nodejs事件循环机制。浏览器 Event Loop 是 HTML 中定义的规范。Node Event Loop 是由 libuv 库实现。</p> <h3 id="浏览器事件循环机制-event-loop"><a href="#浏览器事件循环机制-event-loop" class="header-anchor">#</a> 浏览器事件循环机制（Event Loop）</h3> <p>Javascript 有一个 main thread 主线程和 call-stack 调用栈(执行栈)，所有的任务都会被放到调用栈等待主线程执行。</p> <p><strong>主线程</strong></p> <p><strong>宏任务</strong>  script  setTimeout setInterval</p> <p><strong>微任务</strong>  promise</p> <div class="custom-block tip"><p class="custom-block-title">执行顺序</p> <p>1、执行主线程代码，遇到 setTimeout setInterval 该宏任务异步任务重中的回调放置在宏任务队列里面。</p> <p>2、当遇到了Promise的时候，将该任务.then里面的回调放置在微任务队列里面。</p> <p>3、主线程执行完成后，先从微任务队列中拿出来执行。</p> <p>4、微任务执行完成之后，再从宏任务队列中拿出来执行。</p> <p>5、宏任务里面可能还有其他的setTimeout，Promise这个时候，他们的任务会放在下一次循环任务中执行。</p></div> <p>代码示例：</p> <div class="language-js line-numbers-mode"><pre class="language-js"><code>Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise1'</span><span class="token punctuation">)</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'setTimeout1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Promise2'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//执行结果</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><h3 id="nodejs事件循环机制"><a href="#nodejs事件循环机制" class="header-anchor">#</a> nodejs事件循环机制</h3> <h4 id="_1-微任务"><a href="#_1-微任务" class="header-anchor">#</a> 1.微任务</h4> <p>在谈论Node的事件循环机制之前，先补充说明一下 Node 中的“微任务”。这里说的微任务(microtasks)其实是一个统称，包含了两部分：</p> <ul><li>process.nextTick() 注册的回调 （nextTick task queue）</li> <li>promise.then() 注册的回调 （promise task queue）</li></ul> <p>Node 在执行微任务时， 会优先执行 nextTick task queue 中的任务，执行完之后会接着执行 promise task queue 中的任务。所以如果 process.nextTick 的回调与 promise.then 的回调都处于主线程或事件循环中的同一阶段， process.nextTick 的回调要优先于 promise.then 的回调执行。</p> <h4 id="_2-事件循环机制"><a href="#_2-事件循环机制" class="header-anchor">#</a> 2.事件循环机制</h4> <p><img src="F:%5CgithubRes%5Cweb-Knowledge%5Cdocs.vuepress%5Cpublic%5Cimg%5C898684-20200418064231061-1148380902.png" alt=""></p> <p>如图，表示Node执行的整个过程。如果执行了任何非阻塞异步代码（创建计时器、读写文件等），则会进入事件循环。其中事件循环分为六个阶段：</p> <p>由于Pending callbacks、I/O和Close callbacks 阶段是Node内部使用的三个阶段，所以这里主要分析与开发者代码执行更为直接关联的Timers、Poll 和 Check 三个阶段。</p> <p><strong>Timers（计时器阶段）</strong>：从图可见，初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p> <p><strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I / O回调（系统调用相关的回调）。</p> <p><strong>I/O</strong>：仅供内部使用。（详略）</p> <p><strong>Poll（轮询阶段）</strong>：</p> <p>当回调队列不为空时：</p> <p>会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回到后，变为下面的情况。</p> <p>当回调队列为空时（没有回调或所有回调执行完毕）：</p> <p>但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I/O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</p> <p><strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p> <p><strong>Close callbacks</strong>：执行一些关闭回调，比如 <code>socket.on('close', ...)</code>等。</p> <div class="custom-block tip"><p class="custom-block-title">总结&amp;注意</p> <ol><li>每一个阶段都会有一个FIFO回调队列，都会尽可能的执行完当前阶段中所有的回调或到达了系统相关限制，才会进入下一个阶段。</li> <li>Poll 阶段执行的微任务的时机和 Timers 阶段 &amp; Check 阶段的时机不一样，前者是在每一个回调执行就会执行相应微任务，而后者是会在所有回调执行完之后，才统一执行相应微任务。</li></ol></div> <div class="custom-block tip"><p class="custom-block-title">**执行过程**</p> <p>1、执行全局Script的同步代码。</p> <p>2、执行微任务，先执行所有的Next Tick。</p> <p>3、主线程执行完成后，先从微任务队列中拿出来执行。</p> <p>4、微任务执行完成之后，再从宏任务队列中拿出来执行。</p> <p>5、宏任务里面可能还有其他的setTimeout，Promise这个时候，他们的任务会放在下一次循环任务中执行。</p></div> <h4 id="_3-setimmediate、settimeout-setinterval-和-process-nexttick-执行时机对比"><a href="#_3-setimmediate、settimeout-setinterval-和-process-nexttick-执行时机对比" class="header-anchor">#</a> 3.setImmediate、setTimeout/setInterval 和 process.nextTick 执行时机对比</h4> <p>setImmediate：触发一个异步回调，在事件循环的 Check 阶段立即执行。</p> <p>setTimeout：触发一个异步回调，当计时器过期后，在事件循环的 Timers 阶段执行，只执行一次（可用 clearTimeout 取消）。</p> <p>setInterval：触发一个异步回调，每次计时器过期后，都会在事件循环的 Timers 阶段执行一次回调（可用 clearInterval 取消）。</p> <p>process.nextTick：触发一个微任务（异步）回调，既可以在主线程（mainline）中执行，可以存在事件循序的某一个阶段中执行。</p> <h3 id="浏览器端和node端不同点"><a href="#浏览器端和node端不同点" class="header-anchor">#</a> 浏览器端和node端不同点</h3> <ol><li>Node.js可以理解成4个宏任务队列和2个微任务队列，但是执行宏任务时有6个阶段；</li> <li>Node.js，先执行全局Script代码，执行完同步代码调用栈清空后，先从微任务Next Tick Queue中依次取出所有的任务返给调用栈中执行，再从微任务队列Other Microtask Queue中依次取出所有的任务放入调用栈执行。然后开始宏任务的6个阶段，每个阶段都将该宏任务队列中的所有任务取出来执行（注意：这里浏览器不一样，浏览器只取一个），每个宏任务阶段执行完毕后，开始执行微任务，再开始执行下一阶段宏任务。以此构成事件循环。</li> <li>MacroTask包括：setTimeout、setInterval、setImmediate（node）、requestAnimation（浏览器）、IO、UI rendering</li> <li>MicroTask包括process.nextTick(Node)、Promise.then、Object.observe、MutationObserver</li></ol> <p>注意：new Promise() 构造函数里面是同步代码，而非微任务。</p></div> <footer class="page-edit"><!----> <!----></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/web-Knowledge/blog/notes/webpack相关.html" class="prev">
        webpack相关
      </a></span> <!----></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/web-Knowledge/assets/js/app.fe16e1aa.js" defer></script><script src="/web-Knowledge/assets/js/2.c1653dd8.js" defer></script><script src="/web-Knowledge/assets/js/12.e4dc71a4.js" defer></script>
  </body>
</html>
